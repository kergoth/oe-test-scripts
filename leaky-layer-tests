#!/usr/bin/env python2.7
#
# This is a simple script which uses a default configuration (poky/qemux86),
# and adds each available bsp or distro layer to the configuration, one at
# a time, monitoring for changes to the target with bitbake-whatchanged. This
# helps one to identify bsp layers which affect machines other than the ones
# it provides, and distro layers which affect other distros when included.
#
# This script expects the user to be in a functional bitbake environment (that
# is, the setup scripts sourced, with the current directory under the build
# directory).
#
# For layers which cause a delta, a text file holding the verbose
# bitbake-whatchanged output will be written to the current directory.
#
# If the attempt to run bitbake-whatchanged fails (e.g. if there's a parse
# failure), testing of that layer will be skipped.


import argparse
import bb_test
import glob
import os
import sh
import sys


def main(cmdline_args):
    parser = argparse.ArgumentParser(description='Run leaky layer tests')
    parser.add_argument('target', default='core-image-base', nargs='?',
                        help='target to be checked (default: %(default)s)')
    parser.add_argument('excluded', default='poky/meta oe-core/meta poky/meta-yocto oe-core/meta-yocto',
                        nargs='?',
                        help='layers to exclude from processing (default: %(default)s)')

    args = parser.parse_args(cmdline_args[1:])

    try:
        bitbake_env = bb_test.get_bitbake_env()
    except sh.CommandNotFound:
        sys.exit("Error: unable to run bitbake, did you source the setup script?")
    except sh.ErrorReturnCode as exc:
        sys.exit("Error running bitbake -e: {0}".format(exc.message))

    layers = set()
    corebase = bitbake_env['COREBASE']
    lconfs = set(glob.glob('{0}/../*/conf/layer.conf'.format(corebase)))
    lconfs |= set(glob.glob('{0}/../*/*/conf/layer.conf'.format(corebase)))
    for lconf in lconfs:
        layerpath = lconf[:-len('/conf/layer.conf')]
        is_machine_layer = bool(glob.glob('{0}/conf/machine/*.conf'.format(layerpath)))
        is_distro_layer = bool(glob.glob('{0}/conf/distro/*.conf'.format(layerpath)))
        if is_machine_layer or is_distro_layer:
            layers.add(layerpath)

    stampsdir = bitbake_env['STAMPS_DIR']
    baseline_stampdir = '{0}.baseline'.format(stampsdir)

    tmpdir = bitbake_env['TMPDIR']
    sh.rm('-rf', tmpdir)

    baseline_env = os.environ.copy()
    baseline_env['STAMPS_DIR'] = baseline_stampdir

    # Generate the baseline stamps with sstate
    filter_lines('conf/bblayers.conf', lambda l: not l.startswith('BBLAYERS =+ '))
    with bb_test.status('Populating baseline data'):
        bb_test.bitbake('-S', args.target, _env=baseline_env)

    excluded = args.excluded.split()
    for layerpath in layers:
        layerbase = layerpath[len('{0}/../'.format(corebase)):]
        if layerbase in args.excluded:
            continue

        filter_lines('conf/bblayers.conf', lambda l: not l.startswith('BBLAYERS =+ '))
        with open('conf/bblayers.conf', 'a') as f:
            f.write('BBLAYERS =+ "{0}"\n'.format(layerpath))

        sh.rm('-rf', stampsdir)
        sh.cp('-a', baseline_stampdir, stampsdir)
        with bb_test.status('Testing {0}'.format(layerbase)):
            try:
                output = bb_test.run('bitbake-whatchanged', args.target)
            except sh.ErrorReturnCode as exc:
                raise SkipLayer()
            else:
                if output:
                    if 'ERROR message shown' in output:
                        raise SkipLayer()
                    elif 'Summary: (0 changed' not in output:
                        print(output)
                        try:
                            verbose = bb_test.run('bitbake-whatchanged', '-v', args.target)
                        except sh.ErrorReturnCode as exc:
                            raise SkipLayer()
                        else:
                            with open('bitbake-whatchanged.{0}.{1}'.format(os.path.basename(layerpath), args.target), 'w') as f:
                                f.write(verbose)


def filter_lines(filename, keepfunc):
    with open(filename, 'rU') as f:
        lines = f.readlines()

    with open(filename, 'w') as f:
        lines = filter(keepfunc, lines)
        f.writelines(lines)


class SkipLayer(bb_test.StatusMessage):
    def __init__(self):
        super(SkipLayer, self).__init__('skipped')


if __name__ == '__main__':
    bb_test.run_main(main, sys.argv)
